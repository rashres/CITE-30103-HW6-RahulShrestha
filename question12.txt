The developer expected res = 11, but the code used the left shift operator (<<) instead of normal multiplication. Because of operator precedence, b << 1 happens first, turning 3 into 6. 
Then a + 6 = 11 was expected, but depending on interpretation the programmer probably did not mean to shift at all.

To fix this, we can either use parentheses to control the operation or replace the shift with real multiplication.


WHY THE RESULT WAS WRONG?

The problem happened because << is the bit shifting operator, not multiplication. 
The computer shifted the number 3 left by 1 bit instead of doing 3 * 2, so the expression did not work the way the developer thought.

FIX 1:
int a = 5, b = 3, res;
res = a + (b << 1);   // Now b << 1 is clearly done first
printf("%d\n", res);

result: res = 5 + (3 << 1) = 5 + 6 = 11

FIX 2:
int a = 5, b = 3, res;
res = a + b * 2;   // Same meaning as shifting but more readable
printf("%d\n", res);

result: res = 5 + 3 * 2 = 11

